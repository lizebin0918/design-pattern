### 开闭原则（OCP）
   * 尽量扩展方法，增加(扩展)行为，不要修改代码
   * 抽象化是开闭原则的关键 
   > com.lzb.pricinple.open_close
    
### 里氏替换原则（LSP）
    
   * 任何基类出现的地方，子类一定可以出现
   * 在代码中将一个基类对象替换成子类对象，程序不会产生任何错误和异常，反之则不成立
   * 扩展父类功能，不能改变父类原有功能
   * 子类可以扩展自己的方法（子类可以胜任父类工作）
   * 子类重写父类方法，子类可以扩充入参，不能相同
   * 子类重写父类抽象方法，返回值比父类更小
    
#### 依赖倒置原则（DIP）
    
   * 面向接口编程
   * 高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖于抽象
   * Spring的依赖注入
    
#### 接口隔离原则（ISP）
   * 接口行为尽可能细化
   
#### 具体代码

   * `com.lzb.decorator`:装饰者模式（煎饼+鸡蛋+火腿肠）：在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用
   * `com.lzb.chain`:责任链
   * `com.lzb.state`:状态模式
     * 关于状态机的一个极度确切地描述是它是一个有向图形，由一组节点和一组相应的转移函数组成。状态机通过响应一系列事件而“运行”。每个事件都在属于“当前” 节点的转移函数的控制范围内，其中函数的范围是节点的一个子集。函数返回“下一个”（也许是同一个）节点。这些节点中至少有一个必须是终态。当到达终态，状态机停止。
     * 例如订单的状态流转，状态机就是订单，状态是【已审核】、【待支付】、【已支付】等，动作就是【审核】、【支付】、【取消】
   * `com.lzb.strategy`:策略者模式，封装各种算法实现
   * `com.lzb.delegate`:委派模式，老板->项目经理->员工
   * `com.lzb.adapter`:适配器模式：事后补救策略。提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口
   * `com.lzb.template`:模板模式
   * `com.lzb.proxy`:代理模式（动态代理+静态代理）:不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能
   * `com.lzb.singleton`:单例模式（线程安全）
   * `com.lzb.iterator`:迭代器模式
   * `com.lzb.facade`:门面模式
    * 解决易用性，屏蔽复杂性
    * 解决性能问题
    * 解决分布式事务问题
   * `com.lzb.composition`:树状结构的抽象，将单个对象和组合对象看作是树的节点
   * `com.lzb.command`:把请求包含的数据和处理逻辑封装为命令对象
   * `com.lzb.observer`:观察者模式（同步、异步）
